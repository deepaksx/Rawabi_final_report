/**
 * Emirates Rawabi Pre-Discovery Report
 * Hyper-Real Presentation Engine
 * Generated by NXSYS Presentation Generator
 *
 * Features:
 * - Keyboard navigation (arrows, space, page up/down)
 * - Fullscreen mode (F key)
 * - Presenter notes panel (P key)
 * - Audience window for TV/projector (A key)
 * - Animated counters with data-count attribute
 * - Slide transition animations
 */

class Presentation {
    constructor() {
        this.slides = document.querySelectorAll('.slide');
        this.totalSlides = this.slides.length;
        this.currentSlide = 0;
        this.isAnimating = false;
        this.animationDuration = 1000;

        this.init();
    }

    init() {
        this.createIndicators();
        this.bindEvents();
        this.initFindingDetailPanel();
        this.showPreloader();
        this.updateUI();
    }

    // ==========================================
    // Preloader
    // ==========================================
    showPreloader() {
        const preloader = document.getElementById('preloader');

        setTimeout(() => {
            preloader.classList.add('hidden');
            this.goToSlide(0);
            this.animateCounters();
        }, 2500);
    }

    // ==========================================
    // Slide Indicators
    // ==========================================
    createIndicators() {
        const container = document.getElementById('slideIndicators');

        for (let i = 0; i < this.totalSlides; i++) {
            const indicator = document.createElement('div');
            indicator.className = 'slide-indicator';
            indicator.setAttribute('data-slide', i);
            indicator.addEventListener('click', () => this.goToSlide(i));
            container.appendChild(indicator);
        }
    }

    // ==========================================
    // Event Bindings
    // ==========================================
    bindEvents() {
        // Keyboard navigation only
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));

        // Navigation buttons
        document.getElementById('prevSlide').addEventListener('click', () => this.prevSlide());
        document.getElementById('nextSlide').addEventListener('click', () => this.nextSlide());

        // Slide titles nav click handlers
        document.querySelectorAll('.slide-titles-nav .nav-item').forEach((item) => {
            item.addEventListener('click', () => {
                const navIndex = parseInt(item.dataset.nav);
                this.goToSlide(navIndex);
            });
        });
    }

    handleKeyboard(e) {
        switch (e.key) {
            case 'ArrowDown':
            case 'ArrowRight':
            case ' ':
            case 'PageDown':
            case 'Enter':
                e.preventDefault();
                this.nextSlide();
                break;
            case 'ArrowUp':
            case 'ArrowLeft':
            case 'PageUp':
            case 'Backspace':
                e.preventDefault();
                this.prevSlide();
                break;
            case 'Home':
                e.preventDefault();
                this.goToSlide(0);
                break;
            case 'End':
                e.preventDefault();
                this.goToSlide(this.totalSlides - 1);
                break;
            case 'f':
            case 'F':
                e.preventDefault();
                this.toggleFullscreen();
                break;
            case 'p':
            case 'P':
                e.preventDefault();
                this.togglePresenterNotes();
                break;
            case 'a':
            case 'A':
                e.preventDefault();
                this.toggleAudienceWindow();
                break;
            case 'Escape':
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                break;
        }
    }

    // ==========================================
    // Slide Navigation
    // ==========================================
    goToSlide(index) {
        if (this.isAnimating || index === this.currentSlide) return;
        if (index < 0 || index >= this.totalSlides) return;

        this.isAnimating = true;

        // Remove classes from all slides
        this.slides.forEach((slide, i) => {
            slide.classList.remove('active', 'prev', 'next');

            if (i < index) {
                slide.classList.add('prev');
            } else if (i > index) {
                slide.classList.add('next');
            }
        });

        // Activate current slide
        this.slides[index].classList.add('active');
        this.currentSlide = index;

        // Update UI
        this.updateUI();

        // Update presenter notes if in presenter mode
        if (document.body.classList.contains('presenter-mode')) {
            this.updatePresenterNotes();
        }

        // Sync audience window if open
        this.syncAudienceWindow();

        // Animate counters on this slide
        this.animateCountersOnSlide(index);

        // Update finding detail panel
        this.updateFindingDetailPanel();

        // Reset animation lock
        setTimeout(() => {
            this.isAnimating = false;
        }, this.animationDuration);
    }

    nextSlide() {
        if (this.currentSlide < this.totalSlides - 1) {
            this.goToSlide(this.currentSlide + 1);
        }
    }

    prevSlide() {
        if (this.currentSlide > 0) {
            this.goToSlide(this.currentSlide - 1);
        }
    }

    // ==========================================
    // UI Updates
    // ==========================================
    updateUI() {
        // Update progress bar
        const progress = ((this.currentSlide + 1) / this.totalSlides) * 100;
        document.getElementById('progressBar').style.width = `${progress}%`;

        // Update slide counter
        const counter = document.getElementById('slideCounter');
        counter.querySelector('.current').textContent = String(this.currentSlide + 1).padStart(2, '0');

        // Update indicators
        document.querySelectorAll('.slide-indicator').forEach((ind, i) => {
            ind.classList.toggle('active', i === this.currentSlide);
        });

        // Update nav buttons
        document.getElementById('prevSlide').disabled = this.currentSlide === 0;
        document.getElementById('nextSlide').disabled = this.currentSlide === this.totalSlides - 1;

        // Update slide titles nav
        document.querySelectorAll('.slide-titles-nav .nav-item').forEach((item) => {
            const navIndex = parseInt(item.dataset.nav);
            item.classList.toggle('active', navIndex === this.currentSlide);

            // Scroll active item into view
            if (navIndex === this.currentSlide) {
                item.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        });
    }

    // ==========================================
    // Counter Animations
    // ==========================================
    animateCounters() {
        // Initial counters on first load
        this.animateCountersOnSlide(0);
    }

    animateCountersOnSlide(slideIndex) {
        const slide = this.slides[slideIndex];
        const counters = slide.querySelectorAll('[data-count]');

        counters.forEach(counter => {
            // Check if already animated
            if (counter.dataset.animated === 'true') return;

            const target = parseInt(counter.dataset.count);
            const duration = 2000;
            const steps = 60;
            const stepDuration = duration / steps;
            const increment = target / steps;
            let current = 0;

            const timer = setInterval(() => {
                current += increment;
                if (current >= target) {
                    current = target;
                    clearInterval(timer);
                }
                counter.textContent = this.formatNumber(Math.floor(current));
            }, stepDuration);

            counter.dataset.animated = 'true';
        });
    }

    formatNumber(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // ==========================================
    // Fullscreen
    // ==========================================
    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log('Fullscreen error:', err);
            });
        } else {
            document.exitFullscreen();
        }
    }

    // ==========================================
    // Presenter Notes (P key)
    // ==========================================
    togglePresenterNotes() {
        if (document.body.classList.contains('presenter-mode')) {
            document.body.classList.remove('presenter-mode');
            console.log('%c Presenter Notes: OFF ', 'background: #333; color: white; font-weight: bold; padding: 5px 10px; border-radius: 4px;');
        } else {
            document.body.classList.add('presenter-mode');
            this.updatePresenterNotes();
            console.log('%c Presenter Notes: ON ', 'background: #C8102E; color: white; font-weight: bold; padding: 5px 10px; border-radius: 4px;');
        }
    }

    // ==========================================
    // Audience Window (A key)
    // ==========================================
    toggleAudienceWindow() {
        if (this.audienceWindow && !this.audienceWindow.closed) {
            this.audienceWindow.close();
            this.audienceWindow = null;
            console.log('%c Audience Window: CLOSED ', 'background: #333; color: white; font-weight: bold; padding: 5px 10px; border-radius: 4px;');
        } else {
            this.openAudienceWindow();
            console.log('%c Audience Window: OPENED ', 'background: #C8102E; color: white; font-weight: bold; padding: 5px 10px; border-radius: 4px;');
            console.log('%c Drag the window to your TV/projector and press F for fullscreen ', 'background: #333; color: #fff; padding: 5px 10px;');
        }
    }

    openAudienceWindow() {
        // Open a new window for the audience (TV/projector)
        this.audienceWindow = window.open('', 'AudienceView', 'width=1280,height=720');

        if (!this.audienceWindow) {
            alert('Please allow popups for presenter mode to work.\n\nThe audience window will open on your TV/projector.');
            return;
        }

        // Clone the current page for audience view
        const audienceDoc = this.audienceWindow.document;
        audienceDoc.open();
        audienceDoc.write(`
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emirates Rawabi - Audience View</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Hide presenter-only elements */
        .presenter-notes, .presenter-notes-panel, .presenter-mode-indicator,
        .keyboard-hints, .slide-titles-nav, .nav-arrows, .slide-indicators {
            display: none !important;
            width: 0 !important;
        }
        body {
            cursor: none;
            background: #0a0a0a;
            overflow: hidden;
        }

        /* Full width presentation - remove left nav space */
        .presentation {
            margin-left: 0 !important;
            width: 100% !important;
            left: 0 !important;
        }
        .progress-bar {
            left: 0 !important;
            width: 100% !important;
        }
        .slide-counter {
            right: 40px !important;
        }
        .slide {
            width: 100% !important;
        }
        .slide-content {
            margin-right: 0 !important;
            margin-left: auto !important;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    <div class="slide-counter" id="slideCounter">
        <span class="current">01</span>
        <span class="divider">/</span>
        <span class="total">${this.totalSlides}</span>
    </div>
    <div class="presentation" id="presentation">
        ${document.getElementById('presentation').innerHTML}
    </div>
    <script>
        // Sync with presenter window
        let currentSlide = ${this.currentSlide};
        const slides = document.querySelectorAll('.slide');

        function goToSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.remove('active', 'prev', 'next');
                if (i < index) slide.classList.add('prev');
                else if (i > index) slide.classList.add('next');
            });
            slides[index].classList.add('active');

            // Update progress
            const progress = ((index + 1) / slides.length) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('slideCounter').querySelector('.current').textContent =
                String(index + 1).padStart(2, '0');
        }

        goToSlide(currentSlide);

        // Counter animation function
        function formatNumber(num) {
            return num.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');
        }

        function animateCountersOnSlide(slideIndex) {
            const slide = slides[slideIndex];
            const counters = slide.querySelectorAll('[data-count]');

            counters.forEach(counter => {
                if (counter.dataset.animated === 'true') return;

                const target = parseInt(counter.dataset.count);
                const duration = 2000;
                const steps = 60;
                const stepDuration = duration / steps;
                const increment = target / steps;
                let current = 0;

                const timer = setInterval(() => {
                    current += increment;
                    if (current >= target) {
                        current = target;
                        clearInterval(timer);
                    }
                    counter.textContent = formatNumber(Math.floor(current));
                }, stepDuration);

                counter.dataset.animated = 'true';
            });
        }

        // Animate counters on current slide
        animateCountersOnSlide(currentSlide);

        // Listen for messages from presenter
        window.addEventListener('message', (e) => {
            if (e.data.type === 'slideChange') {
                goToSlide(e.data.slideIndex);
                animateCountersOnSlide(e.data.slideIndex);
            }
        });

        // Fullscreen on F key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }
        });
    </script>
</body>
</html>
        `);
        audienceDoc.close();
    }

    syncAudienceWindow() {
        if (this.audienceWindow && !this.audienceWindow.closed) {
            this.audienceWindow.postMessage({
                type: 'slideChange',
                slideIndex: this.currentSlide
            }, '*');
        }
    }

    updatePresenterNotes() {
        const notesBody = document.getElementById('presenterNotesBody');
        const activeSlide = this.slides[this.currentSlide];
        const slideNotes = activeSlide.querySelector('.presenter-notes .notes-content');

        if (slideNotes) {
            notesBody.innerHTML = slideNotes.innerHTML;
        } else {
            notesBody.innerHTML = '<p class="no-notes">No presenter notes for this slide.</p>';
        }
    }

    // ==========================================
    // Finding Detail Panel (click to open, stays open on navigation)
    // ==========================================
    updateFindingDetailPanel() {
        const panel = document.getElementById('findingDetailPanel');
        const body = document.getElementById('findingDetailBody');

        if (!panel || !body) return;

        // Check if panel is currently open
        const isPanelOpen = panel.classList.contains('active');

        // Check if findingDetails exists and has data for current slide
        if (typeof findingDetails !== 'undefined' && findingDetails[this.currentSlide]) {
            // Update content
            this.populateFindingPanel(findingDetails[this.currentSlide]);

            // If panel was open, keep it open (content updated)
            // If panel was closed, keep it closed (user needs to click to open)
        } else {
            // No details for this slide - close panel if open
            if (isPanelOpen) {
                this.closeFindingPanel();
            }
        }
    }

    populateFindingPanel(details) {
        const body = document.getElementById('findingDetailBody');
        if (!body) return;

        // Scroll panel to top
        body.scrollTop = 0;

        // Build the panel content
        let metricsHTML = '';
        if (details.metrics && details.metrics.length > 0) {
            metricsHTML = `
                <div class="detail-metrics">
                    ${details.metrics.map(m => `
                        <div class="metric-item">
                            <div class="metric-value">${m.value}</div>
                            <div class="metric-label">${m.label}</div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        let evidenceHTML = '';
        if (details.evidence && details.evidence.length > 0) {
            evidenceHTML = `
                <div class="detail-section">
                    <h4><i class="fas fa-search"></i> Evidence</h4>
                    <ul class="evidence-list">
                        ${details.evidence.map(e => `<li><i class="fas fa-exclamation-triangle"></i>${e}</li>`).join('')}
                    </ul>
                </div>
            `;
        }

        body.innerHTML = `
            <div class="detail-entity">${details.entity || ''}</div>
            <h3 class="detail-title">${details.title || ''}</h3>

            ${metricsHTML}

            <div class="detail-section">
                <h4><i class="fas fa-exclamation-circle"></i> Core Issue</h4>
                ${details.coreArgument || ''}
            </div>

            ${evidenceHTML}

            ${details.bestPractice ? `
            <div class="detail-section">
                <h4><i class="fas fa-check-circle"></i> Best Practice</h4>
                ${details.bestPractice}
            </div>
            ` : ''}

            ${details.consultingInsight ? `
            <div class="detail-section">
                <h4><i class="fas fa-chart-line"></i> Business Impact</h4>
                ${details.consultingInsight}
            </div>
            ` : ''}
        `;
    }

    openFindingPanel() {
        const panel = document.getElementById('findingDetailPanel');
        const overlay = document.getElementById('panelOverlay');

        if (!panel) return;

        // Only open if current slide has details
        if (typeof findingDetails !== 'undefined' && findingDetails[this.currentSlide]) {
            this.populateFindingPanel(findingDetails[this.currentSlide]);
            panel.classList.add('active');
            if (overlay) overlay.classList.add('active');
            document.body.classList.add('panel-open');
        }
    }

    closeFindingPanel() {
        const panel = document.getElementById('findingDetailPanel');
        const overlay = document.getElementById('panelOverlay');

        if (panel) panel.classList.remove('active');
        if (overlay) overlay.classList.remove('active');
        document.body.classList.remove('panel-open');
    }

    initFindingDetailPanel() {
        const closeBtn = document.getElementById('closeFindingPanel');
        const overlay = document.getElementById('panelOverlay');

        // Close button
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.closeFindingPanel());
        }

        // Overlay click to close
        if (overlay) {
            overlay.addEventListener('click', () => this.closeFindingPanel());
        }

        // Click on finding body to open panel
        document.querySelectorAll('.slide-finding .finding-body').forEach(el => {
            el.style.cursor = 'pointer';
            el.addEventListener('click', () => this.openFindingPanel());
        });

        // Also allow clicking on rating boxes
        document.querySelectorAll('.slide-finding .finding-ratings').forEach(el => {
            el.style.cursor = 'pointer';
            el.addEventListener('click', () => this.openFindingPanel());
        });
    }
}

// ==========================================
// Initialize on DOM Ready
// ==========================================
document.addEventListener('DOMContentLoaded', () => {
    const presentation = new Presentation();

    // Console branding
    console.log(`
%c NXSYS %c Emirates Rawabi Group - Pre-Discovery Report
%c Hyper-Real Presentation Engine

%c Navigation:
  Arrow Keys         -  Navigate slides
  Space / Enter      -  Next slide
  Page Up/Down       -  Navigate slides
  Home / End         -  First / Last slide
  F                  -  Toggle fullscreen
  P                  -  Toggle presenter notes
  A                  -  Toggle audience window (TV)

%c UAE's First AI-Powered SAP Integrator
`,
    'background: #C8102E; color: white; font-size: 20px; font-weight: bold; padding: 10px 20px; border-radius: 4px 0 0 4px;',
    'background: #1a1a1a; color: white; font-size: 14px; padding: 10px 20px; border-radius: 0 4px 4px 0;',
    'color: #666; font-size: 11px;',
    'color: #C8102E; font-size: 11px;',
    'color: #888; font-size: 10px; font-style: italic;'
    );

    // Expose presentation instance for debugging
    window.presentation = presentation;
});

// ==========================================
// Prevent accidental navigation
// ==========================================
window.addEventListener('beforeunload', (e) => {
    // Uncomment to show warning when leaving
    // e.preventDefault();
    // e.returnValue = '';
});

// ==========================================
// Handle visibility change (pause/resume)
// ==========================================
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Presentation hidden
    } else {
        // Presentation visible again
    }
});

// ==========================================
// Findings Table - Search & Filter
// ==========================================
document.addEventListener('DOMContentLoaded', () => {
    // Check if findingsData exists (from findings-data.js)
    if (typeof findingsData === 'undefined') {
        console.warn('Findings data not loaded');
        return;
    }

    const findingsBody = document.getElementById('findingsBody');
    const findingsSearch = document.getElementById('findingsSearch');
    const filterEntity = document.getElementById('filterEntity');
    const filterModule = document.getElementById('filterModule');
    const filterCriticality = document.getElementById('filterCriticality');
    const resultsCount = document.getElementById('resultsCount');

    if (!findingsBody) return;

    // Render findings table
    function renderFindings(data) {
        findingsBody.innerHTML = '';

        data.forEach((finding, index) => {
            const row = document.createElement('tr');
            row.className = `criticality-${finding.criticality.toLowerCase()}`;

            const badgeClass = finding.criticality === 'High' ? 'badge-high' :
                              finding.criticality === 'Medium' ? 'badge-medium' : 'badge-low';

            row.innerHTML = `
                <td class="col-id">${index + 1}</td>
                <td class="col-entity">${finding.entity}</td>
                <td class="col-module">${finding.module}</td>
                <td class="col-process">${finding.process}</td>
                <td class="col-observation">${finding.observation}</td>
                <td class="col-criticality"><span class="badge ${badgeClass}">${finding.criticality}</span></td>
            `;

            findingsBody.appendChild(row);
        });

        if (resultsCount) {
            resultsCount.textContent = data.length;
        }
    }

    // Filter findings
    function filterFindings() {
        const searchTerm = findingsSearch ? findingsSearch.value.toLowerCase() : '';
        const entityFilter = filterEntity ? filterEntity.value : '';
        const moduleFilter = filterModule ? filterModule.value : '';
        const criticalityFilter = filterCriticality ? filterCriticality.value : '';

        const filtered = findingsData.filter(finding => {
            const matchesSearch = !searchTerm ||
                finding.observation.toLowerCase().includes(searchTerm) ||
                finding.entity.toLowerCase().includes(searchTerm) ||
                finding.module.toLowerCase().includes(searchTerm) ||
                finding.process.toLowerCase().includes(searchTerm);

            const matchesEntity = !entityFilter || finding.entity === entityFilter;
            const matchesModule = !moduleFilter || finding.module.includes(moduleFilter);
            const matchesCriticality = !criticalityFilter || finding.criticality === criticalityFilter;

            return matchesSearch && matchesEntity && matchesModule && matchesCriticality;
        });

        renderFindings(filtered);
    }

    // Bind filter events
    if (findingsSearch) findingsSearch.addEventListener('input', filterFindings);
    if (filterEntity) filterEntity.addEventListener('change', filterFindings);
    if (filterModule) filterModule.addEventListener('change', filterFindings);
    if (filterCriticality) filterCriticality.addEventListener('change', filterFindings);

    // Initial render
    renderFindings(findingsData);
});

// ==========================================
// PDF & PPT Export Functionality
// ==========================================
document.addEventListener('DOMContentLoaded', () => {
    const downloadPDFBtn = document.getElementById('downloadPDF');
    const downloadPPTBtn = document.getElementById('downloadPPT');
    const exportModal = document.getElementById('exportModal');
    const exportProgressText = document.getElementById('exportProgressText');
    const exportProgressFill = document.getElementById('exportProgressFill');

    if (!downloadPDFBtn || !downloadPPTBtn) return;

    // PDF Export
    downloadPDFBtn.addEventListener('click', async () => {
        await exportToPDF();
    });

    // PPT Export
    downloadPPTBtn.addEventListener('click', async () => {
        await exportToPPT();
    });

    function showExportModal() {
        exportModal.classList.add('active');
        exportProgressFill.style.width = '0%';
    }

    function hideExportModal() {
        exportModal.classList.remove('active');
    }

    function updateProgress(percent, text) {
        exportProgressFill.style.width = `${percent}%`;
        exportProgressText.textContent = text;
    }

    async function exportToPDF() {
        const { jsPDF } = window.jspdf;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const presentation = document.getElementById('presentation');

        showExportModal();
        updateProgress(0, 'Initializing PDF export...');

        // Store current slide
        const currentSlide = window.presentation ? window.presentation.currentSlide : 0;

        // Hide UI elements
        const elementsToHide = [
            '.slide-titles-nav', '.nav-arrows', '.slide-counter',
            '.download-buttons', '.progress-bar', '.finding-detail-panel',
            '.panel-overlay', '.presenter-notes-panel', '.preloader'
        ];

        const hiddenElements = [];
        elementsToHide.forEach(sel => {
            document.querySelectorAll(sel).forEach(el => {
                hiddenElements.push({ el, display: el.style.display, visibility: el.style.visibility });
                el.style.display = 'none';
                el.style.visibility = 'hidden';
            });
        });

        // Adjust presentation for full-width capture
        const origPresentationStyle = presentation.style.cssText;
        presentation.style.cssText = 'margin-left: 0 !important; width: 100vw !important; left: 0 !important;';

        // Create PDF (landscape 16:9 ratio)
        const pdf = new jsPDF({
            orientation: 'landscape',
            unit: 'px',
            format: [1920, 1080]
        });

        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();

        // Store original slide styles
        const originalStyles = [];
        slides.forEach(slide => {
            originalStyles.push(slide.style.cssText);
        });

        try {
            for (let i = 0; i < totalSlides; i++) {
                updateProgress(Math.round((i / totalSlides) * 90), `Capturing slide ${i + 1} of ${totalSlides}...`);

                // Hide ALL slides first with important overrides
                slides.forEach((slide) => {
                    slide.style.cssText = 'opacity: 0 !important; visibility: hidden !important; transform: none !important; position: absolute !important;';
                    slide.classList.remove('active', 'prev', 'next');
                });

                // Force the current slide to be fully visible - override all CSS
                const activeSlide = slides[i];
                activeSlide.style.cssText = `
                    opacity: 1 !important;
                    visibility: visible !important;
                    transform: none !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    z-index: 9999 !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                `;
                activeSlide.classList.add('active');

                // Wait for render
                await new Promise(r => setTimeout(r, 400));

                // Capture the slide with specific options
                const canvas = await html2canvas(activeSlide, {
                    scale: 1,
                    useCORS: true,
                    allowTaint: true,
                    logging: false,
                    backgroundColor: '#1a1a2e',
                    width: 1920,
                    height: 1080,
                    windowWidth: 1920,
                    windowHeight: 1080,
                    onclone: (clonedDoc) => {
                        // Remove Font Awesome icons that cause CORS issues
                        const icons = clonedDoc.querySelectorAll('i.fas, i.fab, i.far, i.fa');
                        icons.forEach(icon => {
                            icon.style.fontFamily = 'Arial, sans-serif';
                        });
                    }
                });

                // Add to PDF
                if (i > 0) pdf.addPage([1920, 1080], 'landscape');

                const imgData = canvas.toDataURL('image/jpeg', 0.95);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }

            updateProgress(95, 'Finalizing PDF...');
            await new Promise(r => setTimeout(r, 200));

            pdf.save('Emirates-Rawabi-SAP-Pre-Discovery.pdf');
            updateProgress(100, 'Download complete!');

        } catch (error) {
            console.error('PDF export error:', error);
            updateProgress(0, 'Export failed: ' + error.message);
            await new Promise(r => setTimeout(r, 2000));
        }

        // Restore everything
        presentation.style.cssText = origPresentationStyle;

        slides.forEach((slide, idx) => {
            slide.style.cssText = originalStyles[idx];
            slide.classList.remove('active', 'prev', 'next');
        });

        hiddenElements.forEach(({ el, display, visibility }) => {
            el.style.display = display || '';
            el.style.visibility = visibility || '';
        });

        // Restore current slide
        if (window.presentation) {
            setTimeout(() => window.presentation.goToSlide(currentSlide), 100);
        }

        setTimeout(hideExportModal, 1500);
    }

    async function exportToPPT() {
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        const presentation = document.getElementById('presentation');

        showExportModal();
        updateProgress(0, 'Initializing PowerPoint export...');

        // Store current slide
        const currentSlide = window.presentation ? window.presentation.currentSlide : 0;

        // Hide UI elements
        const elementsToHide = [
            '.slide-titles-nav', '.nav-arrows', '.slide-counter',
            '.download-buttons', '.progress-bar', '.finding-detail-panel',
            '.panel-overlay', '.presenter-notes-panel', '.preloader'
        ];

        const hiddenElements = [];
        elementsToHide.forEach(sel => {
            document.querySelectorAll(sel).forEach(el => {
                hiddenElements.push({ el, display: el.style.display, visibility: el.style.visibility });
                el.style.display = 'none';
                el.style.visibility = 'hidden';
            });
        });

        // Adjust presentation for full-width capture
        const origPresentationStyle = presentation.style.cssText;
        presentation.style.cssText = 'margin-left: 0 !important; width: 100vw !important; left: 0 !important;';

        // Create PPT
        const pptx = new PptxGenJS();
        pptx.layout = 'LAYOUT_16x9';
        pptx.title = 'Emirates Rawabi SAP Pre-Discovery Report';
        pptx.author = 'NXSYS';

        // Store original slide styles
        const originalStyles = [];
        slides.forEach(slide => {
            originalStyles.push(slide.style.cssText);
        });

        try {
            for (let i = 0; i < totalSlides; i++) {
                updateProgress(Math.round((i / totalSlides) * 90), `Capturing slide ${i + 1} of ${totalSlides}...`);

                // Hide ALL slides first with important overrides
                slides.forEach((slide) => {
                    slide.style.cssText = 'opacity: 0 !important; visibility: hidden !important; transform: none !important; position: absolute !important;';
                    slide.classList.remove('active', 'prev', 'next');
                });

                // Force the current slide to be fully visible - override all CSS
                const activeSlide = slides[i];
                activeSlide.style.cssText = `
                    opacity: 1 !important;
                    visibility: visible !important;
                    transform: none !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    z-index: 9999 !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                `;
                activeSlide.classList.add('active');

                // Wait for render
                await new Promise(r => setTimeout(r, 400));

                // Capture the slide
                const canvas = await html2canvas(activeSlide, {
                    scale: 1,
                    useCORS: true,
                    allowTaint: true,
                    logging: false,
                    backgroundColor: '#1a1a2e',
                    width: 1920,
                    height: 1080,
                    windowWidth: 1920,
                    windowHeight: 1080,
                    onclone: (clonedDoc) => {
                        // Remove Font Awesome icons that cause CORS issues
                        const icons = clonedDoc.querySelectorAll('i.fas, i.fab, i.far, i.fa');
                        icons.forEach(icon => {
                            icon.style.fontFamily = 'Arial, sans-serif';
                        });
                    }
                });

                const imgData = canvas.toDataURL('image/jpeg', 0.95);

                const pptSlide = pptx.addSlide();
                pptSlide.addImage({
                    data: imgData,
                    x: 0,
                    y: 0,
                    w: '100%',
                    h: '100%'
                });
            }

            updateProgress(95, 'Finalizing PowerPoint...');
            await new Promise(r => setTimeout(r, 200));

            await pptx.writeFile({ fileName: 'Emirates-Rawabi-SAP-Pre-Discovery.pptx' });
            updateProgress(100, 'Download complete!');

        } catch (error) {
            console.error('PPT export error:', error);
            updateProgress(0, 'Export failed: ' + error.message);
            await new Promise(r => setTimeout(r, 2000));
        }

        // Restore everything
        presentation.style.cssText = origPresentationStyle;

        slides.forEach((slide, idx) => {
            slide.style.cssText = originalStyles[idx];
            slide.classList.remove('active', 'prev', 'next');
        });

        hiddenElements.forEach(({ el, display, visibility }) => {
            el.style.display = display || '';
            el.style.visibility = visibility || '';
        });

        // Restore current slide
        if (window.presentation) {
            setTimeout(() => window.presentation.goToSlide(currentSlide), 100);
        }

        setTimeout(hideExportModal, 1500);
    }
});
